"""
Workflow Execution model for tracking workflow execution instances.

This module defines the WorkflowExecution model as specified in the requirements
for tracking workflow execution instances with state, results, and resource usage.
"""

from datetime import datetime
from typing import TYPE_CHECKING, Any, Dict, Optional
from uuid import UUID, uuid4

from sqlalchemy import JSON, Column, DateTime
from sqlalchemy import Enum as SQLEnum
from sqlalchemy import ForeignKey, Integer, Numeric, String, Text
from sqlalchemy.dialects.postgresql import UUID as PostgreSQLUUID
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..models.base import BaseModel, SoftDeleteMixin
from ..workflows.state import WorkflowStatus, WorkflowType

if TYPE_CHECKING:
    from ..models.project import Project
    from ..models.user import User


class WorkflowExecution(BaseModel, SoftDeleteMixin):
    """
    Workflow execution instance model.

    Tracks individual executions of workflows with their
    state, results, and resource usage as specified in requirements.
    """

    __tablename__ = "workflow_executions"

    # Primary identification
    id: Mapped[UUID] = mapped_column(
        PostgreSQLUUID(as_uuid=True),
        primary_key=True,
        default=uuid4,
        index=True,
    )

    # Relationships
    user_id: Mapped[UUID] = mapped_column(
        PostgreSQLUUID(as_uuid=True),
        ForeignKey("users.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )
    project_id: Mapped[Optional[UUID]] = mapped_column(
        PostgreSQLUUID(as_uuid=True),
        ForeignKey("projects.id", ondelete="CASCADE"),
        nullable=True,
        index=True,
    )

    # Workflow classification
    workflow_type: Mapped[str] = mapped_column(
        String(50),
        nullable=False,
        index=True,
        comment="Type of workflow: research, prd, task_generation",
    )

    # Status tracking
    status: Mapped[WorkflowStatus] = mapped_column(
        SQLEnum(WorkflowStatus),
        nullable=False,
        default=WorkflowStatus.PENDING,
        index=True,
        comment="Current execution status: pending, running, completed, failed, cancelled",
    )

    # Data storage
    input_data: Mapped[Dict[str, Any]] = mapped_column(
        JSON,
        nullable=False,
        default=dict,
        comment="Input data provided to workflow execution",
    )
    output_data: Mapped[Dict[str, Any]] = mapped_column(
        JSON,
        nullable=False,
        default=dict,
        comment="Output data generated by workflow execution",
    )
    checkpoint_data: Mapped[Dict[str, Any]] = mapped_column(
        JSON,
        nullable=False,
        default=dict,
        comment="Checkpoint data for resuming failed executions",
    )

    # Error handling
    error_message: Mapped[Optional[str]] = mapped_column(
        Text,
        nullable=True,
        comment="Error message if execution failed",
    )

    # Resource usage tracking
    total_tokens: Mapped[int] = mapped_column(
        Integer,
        nullable=False,
        default=0,
        comment="Total tokens used during execution",
    )
    total_cost: Mapped[float] = mapped_column(
        Numeric(precision=10, scale=6),
        nullable=False,
        default=0.0,
        comment="Total cost incurred during execution",
    )

    # Timestamps
    started_at: Mapped[Optional[datetime]] = mapped_column(
        DateTime(timezone=True),
        nullable=True,
        comment="Execution start timestamp",
    )
    completed_at: Mapped[Optional[datetime]] = mapped_column(
        DateTime(timezone=True),
        nullable=True,
        comment="Execution completion timestamp",
    )

    # Relationships
    user: Mapped["User"] = relationship(
        "User",
        back_populates="workflow_executions",
    )
    project: Mapped[Optional["Project"]] = relationship(
        "Project",
        back_populates="workflow_executions",
    )

    def __repr__(self) -> str:
        return f"<WorkflowExecution(id={self.id}, type={self.workflow_type}, status={self.status})>"

    @property
    def duration_seconds(self) -> Optional[float]:
        """Calculate execution duration in seconds."""
        if self.started_at and self.completed_at:
            return (self.completed_at - self.started_at).total_seconds()
        return None

    @property
    def is_running(self) -> bool:
        """Check if execution is currently running."""
        return self.status == WorkflowStatus.RUNNING

    @property
    def is_completed(self) -> bool:
        """Check if execution is completed successfully."""
        return self.status == WorkflowStatus.COMPLETED

    @property
    def is_failed(self) -> bool:
        """Check if execution failed."""
        return self.status == WorkflowStatus.FAILED

    @property
    def is_cancelled(self) -> bool:
        """Check if execution was cancelled."""
        return self.status == WorkflowStatus.CANCELLED

    @property
    def can_resume(self) -> bool:
        """Check if execution can be resumed from checkpoint."""
        return self.is_failed and bool(self.checkpoint_data)
